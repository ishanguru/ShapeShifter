
	open Ast						(* this should probably be specified @ command line *)
	(* Generated by ast-pp *)
	
	(* indentation utilities *)

	type pp_indentation = {
		pp_indentation_curr : string;
		pp_indentation_prev : pp_indentation option
	}
  
	let pp_indentation_level = ref {
		pp_indentation_curr = "\n"; 
		pp_indentation_prev = None
	}
	
	(* balence push_indent with pop_indent *)
	
	let push_indent _ = 
		pp_indentation_level := {
			pp_indentation_curr = !pp_indentation_level.pp_indentation_curr  ^ "    ";
			pp_indentation_prev = Some(!pp_indentation_level)
		}
	
	let pop_indent _ =
		match !pp_indentation_level.pp_indentation_prev with
			  None -> ()	(* this is actually an error, but we just leave newline *)
			| Some(prev) -> pp_indentation_level := prev
			
	let inner_indent f =
		let str = (push_indent(); f()) in (pop_indent(); str)
	
	(* get the indentation with newline().
	   The default is just a newline, additional pushes are tabs.
	   This way, anytime you want a new line, it will be properly indented *)
	
	let newline _ = !pp_indentation_level.pp_indentation_curr
	
	(* builtin functions *)
	
	let enum _ = "enum"
	let tuple _  = "tuple"
	let string_of_string str = "\"" ^ str ^ "\""
	let string_of_list f l = 
		"["
		^ (inner_indent (fun _ -> newline() ^
			String.concat (";"^newline()) (List.map f l)))
		^ newline() ^ "]"

	let string_of_option f = function
		  None -> "None"
		| Some(x) -> f(x)	

    let string_of_ref f r = f (!r)

	let rec  string_of_op obj = (((function Difference -> "Difference"
| Intersect -> "Intersect"
| Union -> "Union"
| Or -> "Or"
| And -> "And"
| Geq -> "Geq"
| Greater -> "Greater"
| Leq -> "Leq"
| Less -> "Less"
| Neq -> "Neq"
| Equal -> "Equal"
| Div -> "Div"
| Mult -> "Mult"
| Sub -> "Sub"
| Add -> "Add")) obj)

 and  string_of_uop obj = (((function Not -> "Not"
| Neg -> "Neg")) obj)

 and  string_of_typ obj = (((function Void -> "Void"
| Shape -> "Shape"
| String -> "String"
| Bool -> "Bool"
| Dbl -> "Dbl"
| Int -> "Int")) obj)

 and  string_of_bind obj = (((fun (obj1, obj2) -> "(" ^ (string_of_typ obj1) ^ ", " ^ (string_of_string obj2) ^ ")")) obj)

 and  string_of_expr obj = (((function Noexpr -> "Noexpr"
| Call(obj1, obj2) -> "Call(" ^ (string_of_string obj1) ^ ", " ^ ((string_of_list (string_of_expr)) obj2) ^ ")"
| Assign(obj1, obj2) -> "Assign(" ^ (string_of_string obj1) ^ ", " ^ (string_of_expr obj2) ^ ")"
| Unop(obj1, obj2) -> "Unop(" ^ (string_of_uop obj1) ^ ", " ^ (string_of_expr obj2) ^ ")"
| Binop(obj1, obj2, obj3) -> "Binop(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_op obj2) ^ ", " ^ (string_of_expr obj3) ^ ")"
| Id(x) -> "Id(" ^ string_of_string x^")"
| ConePrim -> "ConePrim"
| TetraPrim -> "TetraPrim"
| CylinderPrim -> "CylinderPrim"
| CubePrim -> "CubePrim"
| SpherePrim -> "SpherePrim"
| BoolLit(x) -> "BoolLit(" ^ string_of_bool x^")"
| StrLit(x) -> "StrLit(" ^ string_of_string x^")"
| DblLit(x) -> "DblLit(" ^ string_of_float x^")"
| IntLit(x) -> "IntLit(" ^ string_of_int x^")")) obj)

 and  string_of_stmt obj = (((function Local(obj1, obj2, obj3) -> "Local(" ^ (string_of_typ obj1) ^ ", " ^ (string_of_string obj2) ^ ", " ^ (string_of_expr obj3) ^ ")"
| While(obj1, obj2) -> "While(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_stmt obj2) ^ ")"
| For(obj1, obj2, obj3, obj4) -> "For(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_expr obj2) ^ ", " ^ (string_of_expr obj3) ^ ", " ^ (string_of_stmt obj4) ^ ")"
| If(obj1, obj2, obj3) -> "If(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_stmt obj2) ^ ", " ^ (string_of_stmt obj3) ^ ")"
| Return(x) -> "Return(" ^ string_of_expr x^")"
| Expr(x) -> "Expr(" ^ string_of_expr x^")"
| Block(x) -> "Block(" ^ (string_of_list (string_of_stmt)) x^")")) obj)

 and  string_of_func_decl obj = (((fun s -> "{" ^
		inner_indent (fun _ -> newline() ^ ("typ = " ^ string_of_typ s.typ)
 ^ newline() ^ ("fname = " ^ string_of_string s.fname)
 ^ newline() ^ ("formals = " ^ (string_of_list (string_of_bind)) s.formals)
 ^ newline() ^ ("body = " ^ (string_of_list (string_of_stmt)) s.body)) ^ newline() ^ "}")) obj)

 and  string_of_program obj = (((fun (obj1, obj2) -> "(" ^ ((string_of_list (string_of_bind)) obj1) ^ ", " ^ ((string_of_list (string_of_func_decl)) obj2) ^ ")")) obj)

