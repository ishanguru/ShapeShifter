open Ast						(* this should probably be specified @ command line *)
(* Generated by ast-pp *)

(* indentation utilities *)

type pp_indentation = {
    pp_indentation_curr : string;
    pp_indentation_prev : pp_indentation option
}

let pp_indentation_level = ref {
    pp_indentation_curr = "\n"; 
    pp_indentation_prev = None
}

(* balence push_indent with pop_indent *)

let push_indent _ = 
    pp_indentation_level := {
        pp_indentation_curr = !pp_indentation_level.pp_indentation_curr  ^ "    ";
        pp_indentation_prev = Some(!pp_indentation_level)
    }

let pop_indent _ =
    match !pp_indentation_level.pp_indentation_prev with
          None -> ()	(* this is actually an error, but we just leave newline *)
        | Some(prev) -> pp_indentation_level := prev
        
let inner_indent f =
    let str = (push_indent(); f()) in (pop_indent(); str)

(* get the indentation with newline().
   The default is just a newline, additional pushes are tabs.
   This way, anytime you want a new line, it will be properly indented *)

let newline _ = !pp_indentation_level.pp_indentation_curr

(* builtin functions *)

let enum _ = "enum"
let tuple _ = "tuple"
let string_of_string str = "\"" ^ str ^ "\""
let string_of_list f l = 
    "["
    ^ (inner_indent (fun _ -> newline() ^
        String.concat (";"^newline()) (List.map f l)))
    ^ newline() ^ "]"

let string_of_option f = function
      None -> "None"
    | Some(x) -> f(x)	

let string_of_ref f r = f (!r)

let rec  string_of_op obj = (((function Difference -> "Difference"
| Intersect -> "Intersect"
| Union -> "Union"
| Or -> "Or"
| And -> "And"
| Geq -> "Geq"
| Greater -> "Greater"
| Leq -> "Leq"
| Less -> "Less"
| Neq -> "Neq"
| Equal -> "Equal"
| Div -> "Div"
| Mult -> "Mult"
| Sub -> "Sub"
| Add -> "Add")) obj)

 and  string_of_uop obj = (((function Not -> "Not"
| Neg -> "Neg")) obj)

 and  string_of_typ obj = (((function Void -> "Void"
(* TODO: Add subshapes *)
(* 
| Cylinder -> "Cylinder"
| Cone -> "Cone"
| Tetra -> "Tetra"
| Cube -> "Cube"
| Sphere -> "Sphere"
| Shape -> "Shape"
| String -> "String"
*)
| Shape -> "Shape" 
| String -> "String"
| Bool -> "Bool"
| Dbl -> "Dbl"
| Int -> "Int")) obj)

 and  string_of_bind obj = (((fun (obj1, obj2) -> "(" ^ (string_of_typ obj1) ^ ", " ^ (string_of_string obj2) ^ ")")) obj)

 and  string_of_expr obj = (((function Noexpr -> "Noexpr"
| Call(obj1, obj2) -> "Call(" ^ (string_of_string obj1) ^ ", " ^ ((string_of_list (string_of_expr)) obj2) ^ ")"
| Assign(obj1, obj2) -> "Assign(" ^ (string_of_string obj1) ^ ", " ^ (string_of_expr obj2) ^ ")"
| Unop(obj1, obj2) -> "Unop(" ^ (string_of_uop obj1) ^ ", " ^ (string_of_expr obj2) ^ ")"
| Binop(obj1, obj2, obj3) -> "Binop(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_op obj2) ^ ", " ^ (string_of_expr obj3) ^ ")"
| Id(x) -> "Id(" ^ string_of_string x^")"
| Null -> "Null"
| ConePrim -> "ConePrim"
| TetraPrim -> "TetraPrim"
| CylinderPrim -> "CylinderPrim"
| CubePrim -> "CubePrim"
| SpherePrim -> "SpherePrim"
| BoolLit(x) -> "BoolLit(" ^ string_of_bool x^")"
| StrLit(x) -> "StrLit(" ^ string_of_string x^")"
| DblLit(x) -> "DblLit(" ^ string_of_float x^")"
| IntLit(x) -> "IntLit(" ^ string_of_int x^")")) obj)

 and  string_of_stmt obj = (((function Break -> "Break"
| While(obj1, obj2) -> "While(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_stmt obj2) ^ ")"
| For(obj1, obj2, obj3, obj4) -> "For(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_expr obj2) ^ ", " ^ (string_of_expr obj3) ^ ", " ^ (string_of_stmt obj4) ^ ")"
| If(obj1, obj2, obj3) -> "If(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_stmt obj2) ^ ", " ^ (string_of_stmt obj3) ^ ")"
| Return(x) -> "Return(" ^ string_of_expr x^")"
| Expr(x) -> "Expr(" ^ string_of_expr x^")"
| Local (t, n, e) -> "Local(" ^ (string_of_typ t) ^ ", " ^ (string_of_string n) ^ ", " ^ (string_of_expr e) ^ ")"
| Block(x) -> "Block(" ^ (string_of_list (string_of_stmt)) x^")")) obj)

 and  string_of_func_decl obj = (((fun s -> "{" ^
		inner_indent (fun _ -> newline() ^ ("typ = " ^ string_of_typ s.typ)
 ^ newline() ^ ("fname = " ^ string_of_string s.fname)
 ^ newline() ^ ("formals = " ^ (string_of_list (string_of_bind)) s.formals)
 (* ^ newline() ^ ("locals = " ^ (string_of_list (string_of_bind)) s.locals) (*TODO: Why is locals not in Ast.func_decl anymore, but formals is?*) *)
 
^ newline() ^ ("body = " ^ (string_of_list (string_of_stmt)) s.body)) ^ newline() ^ "}")) obj)

 and  string_of_program obj = (((fun (obj1, obj2) -> "(" ^ ((string_of_list (string_of_bind)) obj1) ^ ", " ^ ((string_of_list (string_of_func_decl)) obj2) ^ ")")) obj)

